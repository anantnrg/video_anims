{
  "version": 0,
  "timeEvents": [
    {
      "name": "learn basics",
      "targetTime": 3.2170166714159456
    },
    {
      "name": "we utilize memory",
      "targetTime": 8.217016671415946
    },
    {
      "name": "memory is divided into two parts",
      "targetTime": 8.967016671415946
    },
    {
      "name": "lets see how they're different",
      "targetTime": 9.717016671415946
    },
    {
      "name": "integers",
      "targetTime": 11.717016671415946
    },
    {
      "name": "floats",
      "targetTime": 12.467016671415946
    },
    {
      "name": "booleans",
      "targetTime": 13.217016671415946
    },
    {
      "name": "last value pushed",
      "targetTime": 14.514674173553122
    },
    {
      "name": "first one to be popped off",
      "targetTime": 15.46445875961729
    },
    {
      "name": "efficient access to data",
      "targetTime": 16.21445875961729
    },
    {
      "name": "but most of the time",
      "targetTime": 18.614458759617296
    },
    {
      "name": "strings",
      "targetTime": 19.364458759617296
    },
    {
      "name": "vectors",
      "targetTime": 20.114458759617296
    },
    {
      "name": "sizes can change",
      "targetTime": 20.864458759617296
    },
    {
      "name": "cannot be stored in the stack",
      "targetTime": 24.412116261754473
    },
    {
      "name": "this is were the heap memory comes into play",
      "targetTime": 26.16615501567263
    },
    {
      "name": "store values of any size",
      "targetTime": 27.66615501567263
    },
    {
      "name": "can grow or shrink",
      "targetTime": 28.41615501567263
    },
    {
      "name": "unlike the stack",
      "targetTime": 29.91615501567263
    },
    {
      "name": "cannot directly access value",
      "targetTime": 32.91615501567263
    },
    {
      "name": "instead, you need to",
      "targetTime": 34.016155015672624
    },
    {
      "name": "create a pointer",
      "targetTime": 34.766155015672624
    },
    {
      "name": "this brings us to our next topic",
      "targetTime": 38.61550877386513
    },
    {
      "name": "allocation and deallocation",
      "targetTime": 43.86550877386513
    },
    {
      "name": "memory leaks",
      "targetTime": 47.61550877386513
    },
    {
      "name": "dangling pointers",
      "targetTime": 48.16550877386513
    },
    {
      "name": "there are two primary approaches",
      "targetTime": 49.66550877386513
    },
    {
      "name": "manual management",
      "targetTime": 50.77997484153742
    },
    {
      "name": "garbage collection",
      "targetTime": 52.84692205791654
    },
    {
      "name": "first lets talk about manual",
      "targetTime": 55.23783911222658
    },
    {
      "name": "for example c provides",
      "targetTime": 56.75726747731253
    },
    {
      "name": "like malloc",
      "targetTime": 58.25726747731253
    },
    {
      "name": "and free",
      "targetTime": 59.00726747731253
    },
    {
      "name": "next lets talk about garbage collection",
      "targetTime": 60.729176991105305
    },
    {
      "name": "langs such as go",
      "targetTime": 62.715131748001696
    },
    {
      "name": "or javascript",
      "targetTime": 63.951086504898086
    },
    {
      "name": "it identifies and recalims",
      "targetTime": 65.95646962688042
    },
    {
      "name": "lets see how rust achieves memory safety",
      "targetTime": 73.40646962688042
    },
    {
      "name": "instead rust uses ownership system",
      "targetTime": 77.15646962688042
    },
    {
      "name": "consists of three concepts",
      "targetTime": 77.90646962688042
    },
    {
      "name": "ownership",
      "targetTime": 78.65646962688042
    },
    {
      "name": "borrowing",
      "targetTime": 79.40646962688042
    },
    {
      "name": "lifetimes",
      "targetTime": 80.15646962688042
    },
    {
      "name": "we will take a look at first two",
      "targetTime": 81.7568904514491
    },
    {
      "name": "first we will learn about the three rules",
      "targetTime": 85.2568904514491
    },
    {
      "name": "each value has one owner",
      "targetTime": 86.0680929137814
    },
    {
      "name": "there can only be one owner",
      "targetTime": 87.22305521119506
    },
    {
      "name": "when owner gone, value gone",
      "targetTime": 88.61198896368843
    },
    {
      "name": "lets look at the first one",
      "targetTime": 89.36198896368843
    },
    {
      "name": "lets assume we have a string",
      "targetTime": 90.17517756939641
    },
    {
      "name": "this string has an owner",
      "targetTime": 92.87576107784804
    },
    {
      "name": "what this will do is",
      "targetTime": 93.62576107784804
    },
    {
      "name": "create a value in the heap",
      "targetTime": 96.19996737488371
    },
    {
      "name": "that points to this value",
      "targetTime": 97.69996737488371
    },
    {
      "name": "we've satisfied the first rule",
      "targetTime": 98.44996737488371
    },
    {
      "name": "next lets look at another scenario",
      "targetTime": 99.19996737488371
    },
    {
      "name": "putting let x = y",
      "targetTime": 100.69996737488371
    },
    {
      "name": "it will transfer ownership of x to y",
      "targetTime": 101.44996737488371
    },
    {
      "name": "if we try to print x",
      "targetTime": 102.19996737488371
    },
    {
      "name": "in rust terms, we say",
      "targetTime": 104.69996737488371
    },
    {
      "name": "lets look at the third and final rule",
      "targetTime": 106.69996737488371
    },
    {
      "name": "what do we mean by scope",
      "targetTime": 108.94996737488371
    },
    {
      "name": "when the main function ends",
      "targetTime": 109.69996737488371
    },
    {
      "name": "the y variable is dropped",
      "targetTime": 110.44996737488371
    },
    {
      "name": "string doesnt have an owner",
      "targetTime": 111.19996737488371
    },
    {
      "name": "so rust drops this value",
      "targetTime": 111.74996737488371
    },
    {
      "name": "lets change the value of x",
      "targetTime": 113.24996737488371
    },
    {
      "name": "since integers are fixed, allocate on stack",
      "targetTime": 113.99996737488371
    },
    {
      "name": "it is instead copied",
      "targetTime": 114.74996737488371
    },
    {
      "name": "there are two integers",
      "targetTime": 115.49996737488371
    },
    {
      "name": "we can do one of two things",
      "targetTime": 116.24996737488371
    }
  ],
  "seed": 302519928
}